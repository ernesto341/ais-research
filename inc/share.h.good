/* share.h 
 *
 * Ernest Richards
 * 
 */

#ifndef _SHARE_H_
#define _SHARE_H_

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>
#include <time.h>

#ifndef SIGQTY
#define SIGQTY 5
#endif

/* 0, 1 - 5 */
extern int ** shm;
extern int ** sigs;
extern char ** t5s;
extern char ** t5shm;
extern int * shmid;
extern int * t5shmid;
extern unsigned char * hdr_data;
extern uint32_t hdr_size;
extern const uint32_t t5_size;
extern const uint32_t shm_size;
extern uint32_t shmkey[];
extern uint32_t t5shmkey[];

char buf[1024];

inline static void dShmids()
{
        int i = 0;
        while (i < 6)
        {
                shmdt(t5shm[i]);
                shmctl(t5shmid[i], IPC_RMID, 0);
                i++;
        }
        i = 0;
        while (i < 6)
        {
                shmdt(shm[i]);
                shmctl(shmid[i], IPC_RMID, 0);
                i++;
        }
}

inline static void fData()
{
        if (hdr_data)
        {
                free(hdr_data);
        }
}

inline static void fShms()
{
        if (shm)
        {
                free(shm);
        }
}

inline static void fShmids()
{
        if (shmid)
        {
                free(shmid);
        }
}

void freeMem (void)
{
        dShmids();

        fShmids();
        fShms();
        fData();
}

inline static void iData()
{
        hdr_data = (unsigned char *)malloc(sizeof(unsigned char) * (hdr_size * 5));
        hdr_size *= 5;
        t5s = (char **)malloc(sizeof(char *) * 5);
        if (hdr_data == NULL || t5s == NULL)
        {
                strncpy(buf, "Unable to allocate sufficient memory\r\n", 38);
                write(2, buf, strlen(buf));
                _exit(-1);
        }
        int i = 0;
        while (i < 5)
        {
                t5s[i++] = (char *)malloc(sizeof(char) * 44);
        }
        i = 0;
        sigs = (int **)malloc(sizeof(int *) * 6);
        while (i < 6)
        {
                sigs[i++] = (int *)malloc(sizeof(int) * 14);
        }
}

inline static void iShms()
{
        shm = (int **)malloc(sizeof(int *) * 6);
        t5shm = (char **)malloc(sizeof(char *) * 6);
        if (shm == NULL || t5shm == NULL)
        {
                strncpy(buf, "Unable to allocate sufficient memory\r\n", 38);
                write(2, buf, strlen(buf));
                _exit(-1);
        }
}

inline static void iShmids()
{
        int i = 0;
        srand(time(NULL));
        shmid = (int *)malloc(sizeof(int) * 6);
        t5shmid = (int *)malloc(sizeof(int) * 6);
        while (i < 6)
        {
                shmid[i] = shmget(shmkey[i], sizeof(int) * 14, IPC_CREAT | IPC_EXCL | 0600);
                if (shmid[i] < 0)
                {
                        strncpy(buf, "unable to get shm with key ", 27);
                        strncat(buf, itoa(shmkey[i]), strlen(itoa(shmkey[i])));
                        strncat(buf, "\r\n", 2);
                        write(2, buf, strlen(buf));
                        _exit(-1);
                }
                t5shmid[i] = shmget(t5shmkey[i], sizeof(char) * 44, IPC_CREAT | IPC_EXCL | 0600);
                if (t5shmid[i] < 0)
                {
                        strncpy(buf, "unable to get t5shm with key ", 29);
                        strncat(buf, itoa(t5shmkey[i]), strlen(itoa(t5shmkey[i])));
                        strncat(buf, "\r\n", 2);
                        write(2, buf, strlen(buf));
                        _exit(-1);
                }
                i++;
        }
}

inline static void aShmids()
{
        int i = 0;
        while (i < 6)
        {
                shm[i] = shmat(shmid[i], (void *) 0, 0);
                t5shm[i] = shmat(t5shmid[i], (void *) 0, 0);
                i++;
        }
}

void initMem()
{
        iData();
        iShms();
        iShmids();

        aShmids();
}

#endif

/* share.h */
